{"meta":{"title":"小森的博客","subtitle":null,"description":null,"author":null,"url":"http://github.com/lgsdaredevil"},"pages":[{"title":"about","date":"2018-07-11T03:27:42.000Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"about/index.html","permalink":"http://github.com/lgsdaredevil/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-07-11T03:26:05.000Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"categories/index.html","permalink":"http://github.com/lgsdaredevil/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-11T03:26:14.000Z","updated":"2018-07-13T11:52:49.733Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/lgsdaredevil/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【转】简洁又快速地处理集合——java8 Stream（下）","slug":"简洁又快速地处理集合——java8 Stream（下）","date":"2018-08-19T02:26:04.000Z","updated":"2018-08-19T02:40:19.631Z","comments":true,"path":"2018/08/19/简洁又快速地处理集合——java8 Stream（下）/","link":"","permalink":"http://github.com/lgsdaredevil/2018/08/19/简洁又快速地处理集合——java8 Stream（下）/","excerpt":"","text":"作者：Howie_Y 主页：www.jianshu.com/u/79638e5f0743 上一篇文章我讲解 Stream 流的基本原理，以及它的基本方法使用，本篇文章我们继续讲解流的其他操作 值得注意的是：学习 Stream 之前必须先学习 lambda 的相关知识。本文也假设读者已经掌握 lambda 的相关知识。 本篇文章主要内容： 一种特化形式的流——数值流 Optional 类 如何构建一个流 collect 方法 并行流相关问题 一. 数值流 前面介绍的如 1int sum = list.stream().map(Person::getAge).reduce(0, Integer::sum); 计算元素总和的方法其中暗含了装箱成本，map(Person::getAge) 方法过后流变成了 Stream类型，而每个 Integer 都要拆箱成一个原始类型再进行 sum 方法求和，这样大大影响了效率。 针对这个问题 Java 8 有良心地引入了数值流 IntStream, DoubleStream, LongStream，这种流中的元素都是原始数据类型，分别是 int，double，long 1. 流与数值流的转换 流转换为数值流 mapToInt(T -&gt; int) : return IntStream mapToDouble(T -&gt; double) : return DoubleStream mapToLong(T -&gt; long) : return LongStream 1IntStream intStream = list.stream().mapToInt(Person::getAge); 当然如果是下面这样便会出错 1LongStream longStream = list.stream().mapToInt(Person::getAge); 因为 getAge 方法返回的是 int 类型（返回的如果是 Integer，一样可以转换为 IntStream） 数值流转换为流 很简单，就一个 boxed 1Stream&lt;Integer&gt; stream = intStream.boxed(); 2. 数值流方法 下面这些方法作用不用多说，看名字就知道： sum() max() min() average() 等… 3. 数值范围 IntStream 与 LongStream 拥有 range 和 rangeClosed 方法用于数值范围处理 IntStream ： rangeClosed(int, int) / range(int, int) LongStream ： rangeClosed(long, long) / range(long, long) 这两个方法的区别在于一个是闭区间，一个是半开半闭区间： rangeClosed(1, 100) ：[1, 100] range(1, 100) ：[1, 100) 我们可以利用 IntStream.rangeClosed(1, 100) 生成 1 到 100 的数值流 123//求 1 到 10 的数值总和：IntStream intStream = IntStream.rangeClosed(1, 10);int sum = intStream.sum(); 二. Optional 类 NullPointerException 可以说是每一个 Java 程序员都非常讨厌看到的一个词，针对这个问题， Java 8 引入了一个新的容器类 Optional，可以代表一个值存在或不存在，这样就不用返回容易出问题的 null。之前文章的代码中就经常出现这个类，也是针对这个问题进行的改进。 Optional 类比较常用的几个方法有： isPresent() ：值存在时返回 true，反之 flase get() ：返回当前值，若值不存在会抛出异常 orElse(T) ：值存在时返回该值，否则返回 T 的值 Optional 类还有三个特化版本 OptionalInt，OptionalLong，OptionalDouble，刚刚讲到的数值流中的 max 方法返回的类型便是这个 Optional 类其中其实还有很多学问，讲解它说不定也要开一篇文章，这里先讲那么多，先知道基本怎么用就可以。 三. 构建流 之前我们得到一个流是通过一个原始数据源转换而来，其实我们还可以直接构建得到流。 1. 值创建流 Stream.of(T…) ： Stream.of(“aa”, “bb”) 生成流 12//生成一个字符串流Stream&lt;String&gt; stream = Stream.of(\"aaa\", \"bbb\", \"ccc\"); Stream.empty() : 生成空流 2. 数组创建流 根据参数的数组类型创建对应的流： Arrays.stream(T[ ]) Arrays.stream(int[ ]) Arrays.stream(double[ ]) Arrays.stream(long[ ]) 值得注意的是，还可以规定只取数组的某部分，用到的是Arrays.stream(T[], int, int) 1234//只取索引第 1 到第 2 位的：int[] a = &#123;1, 2, 3, 4&#125;;Arrays.stream(a, 1, 3).forEach(System.out :: println);//打印 2 ，3 3. 文件生成流 1Stream&lt;String&gt; stream = Files.lines(Paths.get(\"data.txt\")); 每个元素是给定文件的其中一行 4. 函数生成流 两个方法： iterate ： 依次对每个新生成的值应用函数 generate ：接受一个函数，生成一个新的值 123456Stream.iterate(0, n -&gt; n + 2)//生成流，首元素为 0，之后依次加 2Stream.generate(Math :: random)//生成流，为 0 到 1 的随机双精度数Stream.generate(() -&gt; 1)//生成流，元素全为 1 四. collect 收集数据 coollect 方法作为终端操作，接受的是一个 Collector 接口参数，能对数据进行一些收集归总操作 1. 收集 最常用的方法，把流中所有元素收集到一个 List, Set 或 Collection 中 toList toSet toCollection toMap 123List newlist = list.stream.collect(toList());//如果 Map 的 Key 重复了，可是会报错的哦Map&lt;Integer, Person&gt; map = list.stream().collect(toMap(Person::getAge, p -&gt; p)); 2. 汇总 （1）counting 用于计算总和： 1long l = list.stream().collect(counting()); 没错，你应该想到了，下面这样也可以： 1long l = list.stream().count(); 推荐第二种 （2）summingInt ，summingLong ，summingDouble summing，没错，也是计算总和，不过这里需要一个函数参数 计算 Person 年龄总和： 1int sum = list.stream().collect(summingInt(Person::getAge)); 当然，这个可以也简化为： 1int sum = list.stream().mapToInt(Person::getAge).sum(); 除了上面两种，其实还可以： 1int sum = list.stream().map(Person::getAge).reduce(Interger::sum).get(); 推荐第二种 由此可见，函数式编程通常提供了多种方式来完成同一种操作 （3）averagingInt，averagingLong，averagingDouble 看名字就知道，求平均数 1Double average = list.stream().collect(averagingInt(Person::getAge)); 当然也可以这样写 1OptionalDouble average = list.stream().mapToInt(Person::getAge).average(); 不过要注意的是，这两种返回的值是不同类型的 （4）summarizingInt，summarizingLong，summarizingDouble 这三个方法比较特殊，比如 summarizingInt 会返回 IntSummaryStatistics 类型 1IntSummaryStatistics l = list.stream().collect(summarizingInt(Person::getAge)); IntSummaryStatistics 包含了计算出来的平均值，总数，总和，最值，可以通过下面这些方法获得相应的数据 12345getAverage() doublegetCount() longgetMax() intgetMin() intgetSum() long 3. 取最值 maxBy，minBy 两个方法，需要一个 Comparator 接口作为参数 1Optional&lt;Person&gt; optional = list.stream().collect(maxBy(comparing(Person::getAge))); 我们也可以直接使用 max 方法获得同样的结果 1Optional&lt;Person&gt; optional = list.stream().max(comparing(Person::getAge)); 4. joining 连接字符串 也是一个比较常用的方法，对流里面的字符串元素进行连接，其底层实现用的是专门用于字符串连接的 StringBuilder 1234String s = list.stream().map(Person::getName).collect(Collectors.joining());//结果：jackmiketomString s = list.stream().map(Person::getName).collect(Collectors.joining(\",\"));//结果：jack,mike,tom joining 还有一个比较特别的重载方法： 12String s = list.stream().map(Person::getName).collect(Collectors.joining(\" and \", \"Today \", \" play games.\"));//结果：Today jack and mike and tom play games. 即 Today 放开头，play games. 放结尾，and 在中间连接各个字符串 5. groupingBy 分组 groupingBy 用于将数据分组，最终返回一个 Map 类型 1Map&lt;Integer, List&lt;Person&gt;&gt; map = list.stream().collect(groupingBy(Person::getAge)); 例子中我们按照年龄 age 分组，每一个 Person 对象中年龄相同的归为一组 另外可以看出，Person::getAge 决定 Map 的键（Integer 类型），list 类型决定 Map 的值（List类型） 多级分组 groupingBy 可以接受一个第二参数实现多级分组： 1Map&lt;Integer, Map&lt;T, List&lt;Person&gt;&gt;&gt; map = list.stream().collect(groupingBy(Person::getAge, groupingBy(...))); 其中返回的 Map 键为 Integer 类型，值为 Map&lt;t, list 按组收集数据 1Map&lt;Integer, Integer&gt; map = list.stream().collect(groupingBy(Person::getAge, summingInt(Person::getAge))); 该例子中，我们通过年龄进行分组，然后 summingInt(Person::getAge)) 分别计算每一组的年龄总和（Integer），最终返回一个 Map 根据这个方法，我们可以知道，前面我们写的： 1groupingBy(Person::getAge) 其实等同于： 1groupingBy(Person::getAge, toList()) 6. partitioningBy 分区 分区与分组的区别在于，分区是按照 true 和 false 来分的，因此partitioningBy 接受的参数的 lambda 也是 T -&gt; boolean 12345678//根据年龄是否小于等于20来分区Map&lt;Boolean, List&lt;Person&gt;&gt; map = list.stream() .collect(partitioningBy(p -&gt; p.getAge() &lt;= 20));//打印输出&#123; false=[Person&#123;name='mike', age=25&#125;, Person&#123;name='tom', age=30&#125;], true=[Person&#123;name='jack', age=20&#125;]&#125; 同样地 partitioningBy 也可以添加一个收集器作为第二参数，进行类似 groupBy 的多重分区等等操作。 五. 并行 我们通过 list.stream() 将 List 类型转换为流类型，我们还可以通过 list.parallelStream() 转换为并行流。因此你通常可以使用 parallelStream 来代替 stream 方法 并行流就是把内容分成多个数据块，使用不同的线程分别处理每个数据块的流。这也是流的一大特点，要知道，在 Java 7 之前，并行处理数据集合是非常麻烦的，你得自己去将数据分割开，自己去分配线程，必要时还要确保同步避免竞争。 Stream 让程序员能够比较轻易地实现对数据集合的并行处理，但要注意的是，不是所有情况的适合，有些时候并行甚至比顺序进行效率更低，而有时候因为线程安全问题，还可能导致数据的处理错误，这些我会在下一篇文章中讲解。 比方说下面这个例子 1int i = Stream.iterate(1, a -&gt; a + 1).limit(100).parallel().reduce(0, Integer::sum); 我们通过这样一行代码来计算 1 到 100 的所有数的和，我们使用了 parallel 来实现并行。 但实际上是，这样的计算，效率是非常低的，比不使用并行还低！一方面是因为装箱问题，这个前面也提到过，就不再赘述，还有一方面就是 iterate 方法很难把这些数分成多个独立块来并行执行，因此无形之中降低了效率。 流的可分解性 这就说到流的可分解性问题了，使用并行的时候，我们要注意流背后的数据结构是否易于分解。比如众所周知的 ArrayList 和 LinkedList，明显前者在分解方面占优。 我们来看看一些数据源的可分解性情况 数据源可分解性ArrayList极佳LinkedList差IntStream.range极佳Stream.iterate差HashSet好TreeSet好顺序性。 除了可分解性，和刚刚提到的装箱问题，还有一点值得注意的是一些操作本身在并行流上的性能就比顺序流要差，比如：limit，findFirst，因为这两个方法会考虑元素的顺序性，而并行本身就是违背顺序性的，也是因为如此 findAny 一般比 findFirst 的效率要高。 六. 效率 最后再来谈谈效率问题，很多人可能听说过有关 Stream 效率低下的问题。其实，对于一些简单的操作，比如单纯的遍历，查找最值等等，Stream 的性能的确会低于传统的循环或者迭代器实现，甚至会低很多。 但是对于复杂的操作，比如一些复杂的对象归约，Stream 的性能是可以和手动实现的性能匹敌的，在某些情况下使用并行流，效率可能还远超手动实现。好钢用在刀刃上，在适合的场景下使用，才能发挥其最大的用处。 函数式接口的出现主要是为了提高编码开发效率以及增强代码可读性；与此同时，在实际的开发中，并非总是要求非常高的性能，因此 Stream 与 lambda 的出现意义还是非常大的。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://github.com/lgsdaredevil/categories/技术文章/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"stream","slug":"stream","permalink":"http://github.com/lgsdaredevil/tags/stream/"},{"name":"转载","slug":"转载","permalink":"http://github.com/lgsdaredevil/tags/转载/"}]},{"title":"【转】简洁又快速地处理集合——java8 Stream（上）","slug":"简洁又快速地处理集合——java8 Stream（上）","date":"2018-08-19T02:06:50.000Z","updated":"2018-08-19T02:27:16.062Z","comments":true,"path":"2018/08/19/简洁又快速地处理集合——java8 Stream（上）/","link":"","permalink":"http://github.com/lgsdaredevil/2018/08/19/简洁又快速地处理集合——java8 Stream（上）/","excerpt":"","text":"作者：Howie_Y 主页：www.jianshu.com/u/79638e5f0743 Java 8 发布至今也已经好几年过去，如今 Java 也已经向 11 迈去，但是 Java 8 作出的改变可以说是革命性的，影响足够深远，学习 Java 8 应该是 Java 开发者的必修课。 今天给大家带来 Java 8 Stream 讲解，为什么直接讲这个，是因为只要你学完，立刻就能上手，并能让它在你的代码中大展身手。 值得注意的是：学习 Stream 之前必须先学习 lambda 的相关知识。本文也假设读者已经掌握 lambda 的相关知识。 本篇文章主要内容： 介绍 Stream 以及 Stream 是如何处理集合的 介绍 Stream 与集合的关系与区别 Stream 的基本方法介绍 一. 什么是 Stream Stream 中文称为 “流”，通过将集合转换为这么一种叫做 “流” 的元素序列，通过声明性方式，能够对集合中的每个元素进行一系列并行或串行的流水线操作。 换句话说，你只需要告诉流你的要求，流便会在背后自行根据要求对元素进行处理，而你只需要 “坐享其成”。 二. 流操作 整个流操作就是一条流水线，将元素放在流水线上一个个地进行处理。 其中数据源便是原始集合，然后将如 List的集合转换为 Stream类型的流，并对流进行一系列的中间操作，比如过滤保留部分元素、对元素进行排序、类型转换等；最后再进行一个终端操作，可以把 Stream 转换回集合类型，也可以直接对其中的各个元素进行处理，比如打印、比如计算总数、计算最大值等等 很重要的一点是，很多流操作本身就会返回一个流，所以多个操作可以直接连接起来，我们来看看一条 Stream 操作的代码： 如果是以前，进行这么一系列操作，你需要做个迭代器或者 foreach 循环，然后遍历，一步步地亲力亲为地去完成这些操作；但是如果使用流，你便可以直接声明式地下指令，流会帮你完成这些操作。 有没有想到什么类似的？是的，就像 SQL 语句一样， select username from user where id = 1，你只要说明：“我需要 id 是 1 （id = 1）的用户（user）的用户名（username ）”，那么就可以得到自己想要的数据，而不需要自己亲自去数据库里面循环遍历查找。 三. 流与集合 什么时候计算 Stream 和集合的其中一个差异在于什么时候进行计算。 一个集合，它会包含当前数据结构中所有的值，你可以随时增删，但是集合里面的元素毫无疑问地都是已经计算好了的。 流则是按需计算，按照使用者的需要计算数据，你可以想象我们通过搜索引擎进行搜索，搜索出来的条目并不是全部呈现出来的，而且先显示最符合的前 10 条或者前 20 条，只有在点击 “下一页” 的时候，才会再输出新的 10 条。 再比方在线观看电影和你硬盘里面的电影，也是差不多的道理。 外部迭代和内部迭代 Stream 和集合的另一个差异在于迭代。 我们可以把集合比作一个工厂的仓库，一开始工厂比较落后，要对货物作什么修改，只能工人亲自走进仓库对货物进行处理，有时候还要将处理后的货物放到一个新的仓库里面。在这个时期，我们需要亲自去做迭代，一个个地找到需要的货物，并进行处理，这叫做外部迭代。 后来工厂发展了起来，配备了流水线作业，只要根据需求设计出相应的流水线，然后工人只要把货物放到流水线上，就可以等着接收成果了，而且流水线还可以根据要求直接把货物输送到相应的仓库。 这就叫做内部迭代，流水线已经帮你把迭代给完成了，你只需要说要干什么就可以了（即设计出合理的流水线）。 Java 8 引入 Stream 很大程度是因为，流的内部迭代可以自动选择一种合适你硬件的数据表示和并行实现；而以往程序员自己进行 foreach 之类的时候，则需要自己去管理并行等问题。 一次性的流 流和迭代器类似，只能迭代一次。 123Stream&lt;String&gt; stream = list.stream().map(Person::getName).sorted().limit(10); List&lt;String&gt; newList = stream.collect(toList());List&lt;String&gt; newList2 = stream.collect(toList()); 上面代码中第三行会报错，因为第二行已经使用过这个流，这个流已经被消费掉了 四. 方法介绍，开始实战 首先我们先创建一个 Person 泛型的 List 1234List&lt;Person&gt; list = new ArrayList&lt;&gt;();list.add(new Person(\"jack\", 20));list.add(new Person(\"mike\", 25));list.add(new Person(\"tom\", 30)); Person 类包含年龄和姓名两个成员变量 12private String name;private int age; 1. stream() / parallelStream() 最常用到的方法，将集合转换为流 123List list = new ArrayList();// return Stream&lt;E&gt;list.stream(); 而 parallelStream() 是并行流方法，能够让数据集执行并行操作，后面会更详细地讲解 2. filter(T -&gt; boolean) 保留 boolean 为 true 的元素 123456//保留年龄为 20 的 person 元素list = list.stream() .filter(person -&gt; person.getAge() == 20) .collect(toList());//打印输出 [Person&#123;name='jack', age=20&#125;] collect(toList()) 可以把流转换为 List 类型，这个以后会讲解 3. distinct() 去除重复元素，这个方法是通过类的 equals 方法来判断两个元素是否相等的 如例子中的 Person 类，需要先定义好 equals 方法，不然类似[Person{name=’jack’, age=20}, Person{name=’jack’, age=20}] 这样的情况是不会处理的 4. sorted() / sorted((T, T) -&gt; int) 如果流中的元素的类实现了 Comparable 接口，即有自己的排序规则，那么可以直接调用 sorted() 方法对元素进行排序，如 Stream 反之, 需要调用 sorted((T, T) -&gt; int) 实现 Comparator 接口 1234//根据年龄大小来比较：list = list.stream() .sorted((p1, p2) -&gt; p1.getAge() - p2.getAge()) .collect(toList()); 当然这个可以简化为 123list = list.stream() .sorted(Comparator.comparingInt(Person::getAge)) .collect(toList()); 5. limit(long n) 返回前 n 个元素 1234list = list.stream() .limit(2) .collect(toList());//打印输出 [Person&#123;name='jack', age=20&#125;, Person&#123;name='mike', age=25&#125;] 6. skip(long n) 去除前 n 个元素 1234list = list.stream() .skip(2) .collect(toList());//打印输出 [Person&#123;name='tom', age=30&#125;] tips: 用在 limit(n) 前面时，先去除前 m 个元素再返回剩余元素的前 n 个元素 limit(n) 用在 skip(m) 前面时，先返回前 n 个元素再在剩余的 n 个元素中去除 m 个元素 12345list = list.stream() .limit(2) .skip(1) .collect(toList());//打印输出 [Person&#123;name='mike', age=25&#125;] 7. map(T -&gt; R) 将流中的每一个元素 T 映射为 R（类似类型转换） 12List&lt;String&gt; newlist = list.stream().map(Person::getName).collect(toList()); newlist 里面的元素为 list 中每一个 Person 对象的 name 变量 8. flatMap(T -&gt; Stream**)** 将流中的每一个元素 T 映射为一个流，再把每一个流连接成为一个流 1234567List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"aaa bbb ccc\");list.add(\"ddd eee fff\");list.add(\"ggg hhh iii\");list = list.stream().map(s -&gt; s.split(\" \")).flatMap(Arrays::stream).collect(toList()); 上面例子中，我们的目的是把 List 中每个字符串元素以” “分割开，变成一个新的 List。 首先 map 方法分割每个字符串元素，但此时流的类型为 Stream，因为 split 方法返回的是 String[ ] 类型；所以我们需要使用 flatMap 方法，先使用Arrays::stream将每个 String[ ] 元素变成一个 Stream流，然后 flatMap 会将每一个流连接成为一个流，最终返回我们需要的 Stream 9. anyMatch(T -&gt; boolean) 流中是否有一个元素匹配给定的 T -&gt; boolean 条件 12//是否存在一个 person 对象的 age 等于 20：boolean b = list.stream().anyMatch(person -&gt; person.getAge() == 20); 10. allMatch(T -&gt; boolean) 流中是否所有元素都匹配给定的 T -&gt; boolean 条件 11. noneMatch(T -&gt; boolean) 流中是否没有元素匹配给定的 T -&gt; boolean 条件 12. findAny() 和 findFirst() findAny()：找到其中一个元素 （使用 stream() 时找到的是第一个元素；使用 parallelStream() 并行时找到的是其中一个元素） findFirst()：找到第一个元素 值得注意的是，这两个方法返回的是一个 Optional**对象，它是一个容器类，能代表一个值存在或不存在，这个后面会讲到 13. reduce((T, T) -&gt; T) 和 reduce(T, (T, T) -&gt; T) 用于组合流中的元素，如求和，求积，求最大值等 1234//计算年龄总和：int sum = list.stream().map(Person::getAge).reduce(0, (a, b) -&gt; a + b);//与之相同:int sum = list.stream().map(Person::getAge).reduce(0, Integer::sum); 其中，reduce 第一个参数 0 代表起始值为 0，lambda (a, b) -&gt; a + b 即将两值相加产生一个新值。 同样地： 1234//计算年龄总乘积：int sum = list.stream().map(Person::getAge).reduce(1, (a, b) -&gt; a * b);//当然也可以Optional&lt;Integer&gt; sum = list.stream().map(Person::getAge).reduce(Integer::sum); 即不接受任何起始值，但因为没有初始值，需要考虑结果可能不存在的情况，因此返回的是 Optional 类型。 13. count() 返回流中元素个数，结果为 long 类型 14. collect() 收集方法，我们很常用的是 collect(toList())，当然还有 collect(toSet()) 等，参数是一个收集器接口，这个后面会另外讲。 15. forEach() 返回结果为 void，很明显我们可以通过它来干什么了，比方说： 1234//### 16. unordered()还有这个比较不起眼的方法，//#返回一个等效的无序流，当然如果流本身就是无序的话，那可能就会直接返回其本身//打印各个元素：list.stream().forEach(System.out::println); 再比如说 MyBatis 里面访问数据库的 mapper 方法： 12//向数据库插入新元素：list.stream().forEach(PersonMapper::insertPerson);","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://github.com/lgsdaredevil/categories/技术文章/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"stream","slug":"stream","permalink":"http://github.com/lgsdaredevil/tags/stream/"},{"name":"转载","slug":"转载","permalink":"http://github.com/lgsdaredevil/tags/转载/"}]},{"title":"java虚拟机笔记（三）","slug":"java虚拟机笔记（三）","date":"2018-08-11T00:55:58.000Z","updated":"2018-08-11T02:04:55.986Z","comments":true,"path":"2018/08/11/java虚拟机笔记（三）/","link":"","permalink":"http://github.com/lgsdaredevil/2018/08/11/java虚拟机笔记（三）/","excerpt":"","text":"虚拟机类加载机制类加载时机​ 类从被加载到虚拟机内存开始到卸载内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 ​ 类必须立即初始化情况： 遇到 new、getstatic、putstatic和invokestatic这4条字节码指令时。 使用java.lang.reflect包方法对类进行反射调用时候。 当初始化一个类的时候，欺父类没有被初始化要先初始化其父类。 虚拟机启动时用户需要指定要执行的主类（包括main方法），虚拟机会先初始化这个主类。 如果一个java.lang.reflect.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有初始化，则先触发其初始化。 类加载过程加载 通过一个类的全限定名获取此类的二进制字节流。 将这个字节流所代表的的静态存储结构转换成方法区的运行时数据结构。 在内存生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口。 验证​ 是连接阶段的第一步，这个阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机的自身安全。 文件格式验证 第一阶段验证字节流是否符合Class文件格式规范，并能被当前版本虚拟机处理。 云数据验证 第二阶段对字节码描述的信息进行语义分析，确保描述信息符合Java语言要求规范。 字节码验证 第三阶段对类的方法体进行校验分析，保证被校验的方法在运行时不会出现危害虚拟机的安全事件。 符号引用验证 对类自身以外（常量池中的各种符号引用）的信息进行匹配校验。 准备​ 正式为变量分配内存并设置初始值的阶段，这些变量使用的内存将在方法区中分配。仅包括类变量（被static修饰）不包括实例变量。赋初值是指数据类型的零值。 解析​ 将常量池中的符号引用替换为直接引用。 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量。 直接引用：可以直接指向目标的指针、相对偏移量或能间接的定位到目标的句柄。 初始化执行类中定义的Java程序代码，初始化阶段是执行类构造器（\\()）方法的过程。 类加载器启动类加载器、扩展类加载器、应用程序类加载器。 双亲委派模型 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器的父子关系一般是组合关系来复用父加载器的代码。 ​ 工作过程：如果一个类加载器收到类加载请求，首先会把这个请求为派给父类加载器去完成，每一层的类加载器都是这样的，因此所有请求都传给顶层的启动类加载器，只有当父类加载器反馈无法完成加载请求，子类才会尝试自己加载。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://github.com/lgsdaredevil/categories/技术文章/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://github.com/lgsdaredevil/tags/jvm/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://github.com/lgsdaredevil/tags/虚拟机/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://github.com/lgsdaredevil/tags/读书笔记/"}]},{"title":"java虚拟机笔记（二）","slug":"java虚拟机笔记（二）","date":"2018-08-04T01:35:56.000Z","updated":"2018-08-04T08:46:04.295Z","comments":true,"path":"2018/08/04/java虚拟机笔记（二）/","link":"","permalink":"http://github.com/lgsdaredevil/2018/08/04/java虚拟机笔记（二）/","excerpt":"","text":"判断对象是否存活一、引用计数算法​ 给对象中添加一个引用计数器，每当有一个地方引用他时就给计数器值加一；当引用失效时，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。 ​ 缺点：很难解决对象之间互相循环引用的问题。 二、可达性分析算法​ 以“GC Root”对象为起始点，从此节点向下搜索，搜索所走的路径成为引用链，当一个对象和GC Root之间没有任何引用链的时候，则此对象为不可用对象。 如上图所示，Object1到Object4与GC Root之间存在引用链，所以Object1到Object4的对象是可达对象，而Object5和Object6没有雨GC Root相关的引用链，所以Object5和Object6是不可达对象，是可以回收的对象。 ​ Java中可以被称为GC Root的对象有以下几种： 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 三、四种引用类型 强引用：类似于new一个对象的引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：描述的是一些还有用但并非必须的对象，对于软引用关联的对象，在系统将要发生内存溢出之前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存就会抛出内存溢出异常。 弱引用：描述非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。 虚引用：一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是当这个对象被收集器收集时会收到一个系统通知。 如果一个对象在可达性分析时没后没有与GC Root相连接的引用链，它将会第一次标记并筛选，筛选条件是该对象是否有必要执行finalize()方法，如果有必要执行finalize()方法，对象只要重新与引用链上的任何一个对象建立关联即可，拿在第二次标记时将他移除“即将回收”集合。任何对象的finalize()方法只会被调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。 垃圾收集算法一、标记—清除算法​ 首先标记出所有要回收的对象，在标记完成后统一回收被标记的对象。 ​ 缺点：1、效率问题，标记和清除两个过程的效率都不高。 2、空间问题，标记清除会产生大量不连续的内存碎片，空间碎片太多会导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得进行另一次垃圾收集动作。 二、复制算法​ 将内存安容量分为大小相等的两块，每次只使用其中一块，当着一块内存用完后，将存活的对象复制到另一块上面，再把已使用的内存清理掉。 ​ 一般虚拟机是将内存分为一块较大的Eden空间和两块较小的Survivor空间。每次使用？Eden和其中一块Survivor，回收时，将Eden和Survivor还存后的对象复制到Survivor空间，再清理掉刚才用到的Survivor和Eden空间。当Survivor内存不足时会用到其他内存（老年代）进行分配担保。 ​ 缺点：在对象存活率较高时就要进行较多的复制操作，效率会变低，老年代一般不能直接选用这种做法。 三、标记—整理算法​ 标记过程与标记—清除算法相同，然后让所有存活的对象都像一端移动，然后直接清理掉端边界以外的内存。适用于老年代整理。 四、分代收集算法​ 一般根据对象存活周期将对象划分为几块。Java堆分为新生代和老年代。新生代一般采用复制算法，而老年代对象存活较高，没有额外空间对它进行分配担保，就必须使用标记—清除或标记—整理算法。 垃圾收集器一、Serial收集器​ 是虚拟机在client模式下默认的新生代收集器，是单线程收集器，必须停掉其他所有工作线程，知道他收集结束。 二、ParNew收集器​ 时Serial收集器的多线程版本。是许多运行在server模式下的虚拟机的首选的新生代收集器。除了Serial收集器外，只有它能与CMS收集器配合工作。 三、Parallel Scavenge收集器​ 并行多线程的新生代收集器。CMS等收集器的特点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制吞吐量。吞吐量是指CPU用于运行用户代码的时间与CPU总消耗的时间的比值 四、Serial Old收集器​ 是Serial收集器的老年代版本，单线程收集器。主要是给client模式下的虚拟机使用。在server模式下：一是可以与Parallel Scavenge收集器配合使用。另一方面是作为CMS收集器的后备方案。 五、Parallel Old收集器​ 是Parallel Scavenge收集器的老年代版本，使用多线程和标记—整理算法。 六、CMS收集器​ 是一种以获取最短回收时间为目标的收集器。基于标记—清除算法实现。运作过程： 初始标记 并发标记 重新标记 并发清除 其中初始标记和重新标记需要“stop the world”，并发标记和并发清除是和用户线程一起进行的。 缺点：1、对CPU资源敏感，因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。 ​ 2、收集器无法处理浮动垃圾。 ​ 3.采用标记—清除算法会产生大量空间碎片。 七、G1收集器​ 面向服务端应用的垃圾收集器。优点如下： 并行并发 分代收集 空间整合 可预测停顿 它将整个Java堆分为多个大小相等的独立区域，保留新生代和老年代概念，但他们不是物理隔离，都是一部分Region的集合。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的手机时间，优先回收价值大的Region。 G1的操作步骤： 初始标记 并发标记 最终标记 筛选回收 内存分配与回收策略一、对象优先在Eden分配二、大对象直接进入老年代​ 需要大量连续的内存空间的Java对象，最典型就是很长的字符串以及数组。 三、长期存活的对象进入老年代​ 虚拟机给每一个对象定义年龄计数器，在Eden代出生并经过一次Minor GC仍存后，并能被Survivor接收，被移到Survivor空间中，年龄加一。在Survivor中每熬过一次GC，年龄就加一。当年龄到一定长度后就进入老年代。 四、动态对象年龄判断​ 如果在Survivor中的相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于改年龄的对象就会进入老年代。 五、空间分配担保​ 在Minor GC前虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立，那么Minor GC可以确保安全。否则虚拟机会查看HandelPromotionFailure设置的值是否允许担保失败，如果是，则在检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，尝试进行一次Minor GC。否则进行一次Full GC","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://github.com/lgsdaredevil/categories/技术文章/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://github.com/lgsdaredevil/tags/jvm/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://github.com/lgsdaredevil/tags/虚拟机/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://github.com/lgsdaredevil/tags/读书笔记/"}]},{"title":"java虚拟机笔记（一）","slug":"java虚拟机笔记（一）","date":"2018-07-28T00:43:53.000Z","updated":"2018-07-28T02:44:11.535Z","comments":true,"path":"2018/07/28/java虚拟机笔记（一）/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/28/java虚拟机笔记（一）/","excerpt":"","text":"JDK和JRE区别​ 1、一般把Java程序设计语言，java虚拟机，java API类库这三部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境。 ​ 2、Java API类库中Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境。 Java虚拟机内存区域一、程序计数器​ 可以看做当前线程所执行的字节码的行号指示器。为线程私有的内存。是在Java虚拟机内存区域唯一一个不会内存溢出的区域。 二、Java虚拟机栈​ Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链栈、方法出口等信息。Java虚拟机栈也是线程私有，生命周期和线程相同。 ​ Java虚拟机栈中的局部变量表：存放编译期可知的各种基本数据类型、引用类型（reference）和runAddress类型。局部变量表所需要的内存空间在编译期间完成内存分配，在方法运行期间不会改变局部变量表的大小。 ​ 异常： 1）StackOverflowError：线程请求的栈的深度大于虚拟机所允许的深度。 2）OutOfMemoryError：扩展时无法申请到足够的内存。 三、本地方法栈​ 与Java虚拟机栈类似，线程私有，会抛出StackOverflowError和OutOfMemoryError异常。 ​ Java虚拟机栈区别是本地方法栈为虚拟机使用的Native方法服务，Java虚拟机栈为虚拟机执行Java方法服务。 四、Java堆​ 存放对象实例，被所有线程共享，虚拟机启动时创建。Java堆又称GC堆，垃圾收集器管理的主要区域。 ​ Java堆可以细分为：新生代和老年代。也可以分为Eden空间、From Survivor空间、To Survivor空间等。 如果在堆中没有内存完成实例分配，并且也无法再扩展，会抛出OutOfMemoryError异常 五、方法区​ 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是线程共享的区域。 ​ 与java堆一样不需要连续的内存和可以选择的固定大小并且可以扩展。不同点是可以选择不实现垃圾收集，这个区域主要的内存回收目标是针对常量池的回收和对类型的卸载。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 六、运行时常量池​ 是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。具备动态特性，运行时也能将新的常量存放入池。同样在无法申请内存时会抛出OutOfMemoryError异常。 七、直接内存​ 不是虚拟机运行数据区的一部分。NIO类可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。也会抛OutOfMemoryErrory异常","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://github.com/lgsdaredevil/categories/技术文章/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://github.com/lgsdaredevil/tags/jvm/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://github.com/lgsdaredevil/tags/虚拟机/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://github.com/lgsdaredevil/tags/读书笔记/"}]},{"title":"spring boot使用@Async异步任务","slug":"spring-boot使用@Async异步任务","date":"2018-07-17T03:04:05.000Z","updated":"2018-07-28T02:43:57.424Z","comments":true,"path":"2018/07/17/spring-boot使用@Async异步任务/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/17/spring-boot使用@Async异步任务/","excerpt":"","text":"github项目地址：https://github.com/lgsdaredevil/asyncTest 开启异步任务在应用主类中添加@EnableAsync注解 写异步任务方法12345678910111213@Async public Future&lt;String&gt; ansync(String name)&#123; try &#123; Thread.sleep(10000); logger.info(\"这里是异步方法\"); logger.info(\"传过来的名字是：\" + name); name = \"修改的名字\"; logger.info(\"修改后的名字是：\" + name); return new AsyncResult&lt;&gt;(\"name: \" + name); &#125;catch (Exception e)&#123; return new AsyncResult&lt;&gt;(\"异常\"); &#125; &#125; 调用异步方法 1、用Future获取返回值12345678910111213141516public String requestAnsync(String name)&#123; try &#123; Long start = System.currentTimeMillis(); Future&lt;String&gt; result = ansync(name); if (result.isDone())&#123; name = result.get(); logger.info(\"异步方法结束，名字改为：\" + name); &#125; Long end = System.currentTimeMillis(); logger.info(\"耗时：\" + (int)(end-start)); return \"hello \" + name; &#125;catch (Exception e)&#123; logger.error(\"异常\"); return \"异常\"; &#125; &#125; 返回值，若想获取到返回值，应该轮询方法获取，否则若果没有isDone则不会走下面的方法，或者可以使用CompletableFuture：12342018-07-17 11:31:55.390 INFO 5232 --- [nio-8080-exec-6] c.e.async.service.AsyncTestService : 耗时：02018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 这里是异步方法2018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 传过来的名字是：ling2018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 修改后的名字是：修改的名字 如果使用future.get()方法会阻塞线程直到拿到结果。 2、不使用future.get()方法，异步方法不使用Future返回1234567891011@Asyncpublic void noReturnAsync(String name)&#123; try &#123; Thread.sleep(10000); logger.info(\"这里是异步方法\"); logger.info(\"传过来的名字是：\" + name); name = \"修改的名字\"; logger.info(\"修改后的名字是：\" + name); &#125;catch (Exception e)&#123; &#125;&#125; 调用异步的方法1234567public String noReturn(String name)&#123; Long start = System.currentTimeMillis(); asyncTest.noReturnAsync(name); Long end = System.currentTimeMillis(); logger.info(\"耗时：\" + (int)(end-start)); return \"hello \" + name; &#125; 注意的地方：如果异步方法变成阻塞的同步方法，可能原因是异步方法和普通的调用方法在同一个类中，解决方法是将异步方法单独放到一个类中。产生原因：spring对@Transactional注解时也有类似问题，spring扫描时具有@Transactional注解方法的类时，是生成一个代理类，由代理类去开启关闭事务，而在同一个类中，方法调用是在类体内执行的，spring无法截获这个方法调用。具体参见：Spring Boot使用@Async实现异步调用","categories":[{"name":"技术文章项目","slug":"技术文章项目","permalink":"http://github.com/lgsdaredevil/categories/技术文章项目/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://github.com/lgsdaredevil/tags/spring-boot/"},{"name":"Async","slug":"Async","permalink":"http://github.com/lgsdaredevil/tags/Async/"},{"name":"异步","slug":"异步","permalink":"http://github.com/lgsdaredevil/tags/异步/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-13T11:52:49.718Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"2018/07/13/hello-world/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"部署hexo博客到github","slug":"部署hexo博客到github","date":"2018-07-11T07:55:19.000Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"2018/07/11/部署hexo博客到github/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/11/部署hexo博客到github/","excerpt":"","text":"部署hexo博客到github准备工具&nbsp;&nbsp;&nbsp;&nbsp;Node.js&nbsp;&nbsp;&nbsp;&nbsp;Git&nbsp;&nbsp;&nbsp;&nbsp;GitHub Hexo安装在新目录下输入命令：npm install -g hexo-cli 创建博客文件夹博客目录下输入命令：hexo init 安装依赖包npm install 修改配置文件修改_config.yml文件 url: http://github.com/ root: /newblog permalink: :year/:month/:day/:title/ permalink_defaults:root为文件目录的跟目录 deploy: # 部署相关配置 type: git # 使用 Git 提交 repository: https://github.com/xxx/xxx.github.io.git # 博客仓库地址 repository后地址为github的项目地址 生成文件hexo g 或者 hexo generate 启动服务hexo s 或 hexo server浏览器输入 http://localhost:4000/(root的目录)查看 发布hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 注意如果发布时候报错： ERROR Deployer not found: Git输入命令：npm install hexo-deployer-git –save，重新发布即可","categories":[{"name":"个人博客","slug":"个人博客","permalink":"http://github.com/lgsdaredevil/categories/个人博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://github.com/lgsdaredevil/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://github.com/lgsdaredevil/tags/github/"},{"name":"部署博客","slug":"部署博客","permalink":"http://github.com/lgsdaredevil/tags/部署博客/"}]}]}