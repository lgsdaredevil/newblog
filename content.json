{"meta":{"title":"小森的博客","subtitle":null,"description":null,"author":null,"url":"http://github.com/lgsdaredevil"},"pages":[{"title":"about","date":"2018-07-11T03:27:42.000Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"about/index.html","permalink":"http://github.com/lgsdaredevil/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-11T03:26:14.000Z","updated":"2018-07-13T11:52:49.733Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/lgsdaredevil/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-07-11T03:26:05.000Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"categories/index.html","permalink":"http://github.com/lgsdaredevil/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"java虚拟机笔记（三）","slug":"java虚拟机笔记（三）","date":"2018-08-11T00:55:58.000Z","updated":"2018-08-11T02:04:55.986Z","comments":true,"path":"2018/08/11/java虚拟机笔记（三）/","link":"","permalink":"http://github.com/lgsdaredevil/2018/08/11/java虚拟机笔记（三）/","excerpt":"","text":"虚拟机类加载机制类加载时机​ 类从被加载到虚拟机内存开始到卸载内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 ​ 类必须立即初始化情况： 遇到 new、getstatic、putstatic和invokestatic这4条字节码指令时。 使用java.lang.reflect包方法对类进行反射调用时候。 当初始化一个类的时候，欺父类没有被初始化要先初始化其父类。 虚拟机启动时用户需要指定要执行的主类（包括main方法），虚拟机会先初始化这个主类。 如果一个java.lang.reflect.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有初始化，则先触发其初始化。 类加载过程加载 通过一个类的全限定名获取此类的二进制字节流。 将这个字节流所代表的的静态存储结构转换成方法区的运行时数据结构。 在内存生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口。 验证​ 是连接阶段的第一步，这个阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机的自身安全。 文件格式验证 第一阶段验证字节流是否符合Class文件格式规范，并能被当前版本虚拟机处理。 云数据验证 第二阶段对字节码描述的信息进行语义分析，确保描述信息符合Java语言要求规范。 字节码验证 第三阶段对类的方法体进行校验分析，保证被校验的方法在运行时不会出现危害虚拟机的安全事件。 符号引用验证 对类自身以外（常量池中的各种符号引用）的信息进行匹配校验。 准备​ 正式为变量分配内存并设置初始值的阶段，这些变量使用的内存将在方法区中分配。仅包括类变量（被static修饰）不包括实例变量。赋初值是指数据类型的零值。 解析​ 将常量池中的符号引用替换为直接引用。 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量。 直接引用：可以直接指向目标的指针、相对偏移量或能间接的定位到目标的句柄。 初始化执行类中定义的Java程序代码，初始化阶段是执行类构造器（\\()）方法的过程。 类加载器启动类加载器、扩展类加载器、应用程序类加载器。 双亲委派模型 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器的父子关系一般是组合关系来复用父加载器的代码。 ​ 工作过程：如果一个类加载器收到类加载请求，首先会把这个请求为派给父类加载器去完成，每一层的类加载器都是这样的，因此所有请求都传给顶层的启动类加载器，只有当父类加载器反馈无法完成加载请求，子类才会尝试自己加载。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://github.com/lgsdaredevil/categories/技术文章/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://github.com/lgsdaredevil/tags/jvm/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://github.com/lgsdaredevil/tags/虚拟机/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://github.com/lgsdaredevil/tags/读书笔记/"}]},{"title":"java虚拟机笔记（二）","slug":"java虚拟机笔记（二）","date":"2018-08-04T01:35:56.000Z","updated":"2018-08-04T08:46:04.295Z","comments":true,"path":"2018/08/04/java虚拟机笔记（二）/","link":"","permalink":"http://github.com/lgsdaredevil/2018/08/04/java虚拟机笔记（二）/","excerpt":"","text":"判断对象是否存活一、引用计数算法​ 给对象中添加一个引用计数器，每当有一个地方引用他时就给计数器值加一；当引用失效时，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。 ​ 缺点：很难解决对象之间互相循环引用的问题。 二、可达性分析算法​ 以“GC Root”对象为起始点，从此节点向下搜索，搜索所走的路径成为引用链，当一个对象和GC Root之间没有任何引用链的时候，则此对象为不可用对象。 如上图所示，Object1到Object4与GC Root之间存在引用链，所以Object1到Object4的对象是可达对象，而Object5和Object6没有雨GC Root相关的引用链，所以Object5和Object6是不可达对象，是可以回收的对象。 ​ Java中可以被称为GC Root的对象有以下几种： 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 三、四种引用类型 强引用：类似于new一个对象的引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：描述的是一些还有用但并非必须的对象，对于软引用关联的对象，在系统将要发生内存溢出之前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存就会抛出内存溢出异常。 弱引用：描述非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。 虚引用：一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是当这个对象被收集器收集时会收到一个系统通知。 如果一个对象在可达性分析时没后没有与GC Root相连接的引用链，它将会第一次标记并筛选，筛选条件是该对象是否有必要执行finalize()方法，如果有必要执行finalize()方法，对象只要重新与引用链上的任何一个对象建立关联即可，拿在第二次标记时将他移除“即将回收”集合。任何对象的finalize()方法只会被调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。 垃圾收集算法一、标记—清除算法​ 首先标记出所有要回收的对象，在标记完成后统一回收被标记的对象。 ​ 缺点：1、效率问题，标记和清除两个过程的效率都不高。 2、空间问题，标记清除会产生大量不连续的内存碎片，空间碎片太多会导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得进行另一次垃圾收集动作。 二、复制算法​ 将内存安容量分为大小相等的两块，每次只使用其中一块，当着一块内存用完后，将存活的对象复制到另一块上面，再把已使用的内存清理掉。 ​ 一般虚拟机是将内存分为一块较大的Eden空间和两块较小的Survivor空间。每次使用？Eden和其中一块Survivor，回收时，将Eden和Survivor还存后的对象复制到Survivor空间，再清理掉刚才用到的Survivor和Eden空间。当Survivor内存不足时会用到其他内存（老年代）进行分配担保。 ​ 缺点：在对象存活率较高时就要进行较多的复制操作，效率会变低，老年代一般不能直接选用这种做法。 三、标记—整理算法​ 标记过程与标记—清除算法相同，然后让所有存活的对象都像一端移动，然后直接清理掉端边界以外的内存。适用于老年代整理。 四、分代收集算法​ 一般根据对象存活周期将对象划分为几块。Java堆分为新生代和老年代。新生代一般采用复制算法，而老年代对象存活较高，没有额外空间对它进行分配担保，就必须使用标记—清除或标记—整理算法。 垃圾收集器一、Serial收集器​ 是虚拟机在client模式下默认的新生代收集器，是单线程收集器，必须停掉其他所有工作线程，知道他收集结束。 二、ParNew收集器​ 时Serial收集器的多线程版本。是许多运行在server模式下的虚拟机的首选的新生代收集器。除了Serial收集器外，只有它能与CMS收集器配合工作。 三、Parallel Scavenge收集器​ 并行多线程的新生代收集器。CMS等收集器的特点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制吞吐量。吞吐量是指CPU用于运行用户代码的时间与CPU总消耗的时间的比值 四、Serial Old收集器​ 是Serial收集器的老年代版本，单线程收集器。主要是给client模式下的虚拟机使用。在server模式下：一是可以与Parallel Scavenge收集器配合使用。另一方面是作为CMS收集器的后备方案。 五、Parallel Old收集器​ 是Parallel Scavenge收集器的老年代版本，使用多线程和标记—整理算法。 六、CMS收集器​ 是一种以获取最短回收时间为目标的收集器。基于标记—清除算法实现。运作过程： 初始标记 并发标记 重新标记 并发清除 其中初始标记和重新标记需要“stop the world”，并发标记和并发清除是和用户线程一起进行的。 缺点：1、对CPU资源敏感，因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。 ​ 2、收集器无法处理浮动垃圾。 ​ 3.采用标记—清除算法会产生大量空间碎片。 七、G1收集器​ 面向服务端应用的垃圾收集器。优点如下： 并行并发 分代收集 空间整合 可预测停顿 它将整个Java堆分为多个大小相等的独立区域，保留新生代和老年代概念，但他们不是物理隔离，都是一部分Region的集合。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的手机时间，优先回收价值大的Region。 G1的操作步骤： 初始标记 并发标记 最终标记 筛选回收 内存分配与回收策略一、对象优先在Eden分配二、大对象直接进入老年代​ 需要大量连续的内存空间的Java对象，最典型就是很长的字符串以及数组。 三、长期存活的对象进入老年代​ 虚拟机给每一个对象定义年龄计数器，在Eden代出生并经过一次Minor GC仍存后，并能被Survivor接收，被移到Survivor空间中，年龄加一。在Survivor中每熬过一次GC，年龄就加一。当年龄到一定长度后就进入老年代。 四、动态对象年龄判断​ 如果在Survivor中的相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于改年龄的对象就会进入老年代。 五、空间分配担保​ 在Minor GC前虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立，那么Minor GC可以确保安全。否则虚拟机会查看HandelPromotionFailure设置的值是否允许担保失败，如果是，则在检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，尝试进行一次Minor GC。否则进行一次Full GC","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://github.com/lgsdaredevil/categories/技术文章/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://github.com/lgsdaredevil/tags/jvm/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://github.com/lgsdaredevil/tags/虚拟机/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://github.com/lgsdaredevil/tags/读书笔记/"}]},{"title":"java虚拟机笔记（一）","slug":"java虚拟机笔记（一）","date":"2018-07-28T00:43:53.000Z","updated":"2018-07-28T02:44:11.535Z","comments":true,"path":"2018/07/28/java虚拟机笔记（一）/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/28/java虚拟机笔记（一）/","excerpt":"","text":"JDK和JRE区别​ 1、一般把Java程序设计语言，java虚拟机，java API类库这三部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境。 ​ 2、Java API类库中Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境。 Java虚拟机内存区域一、程序计数器​ 可以看做当前线程所执行的字节码的行号指示器。为线程私有的内存。是在Java虚拟机内存区域唯一一个不会内存溢出的区域。 二、Java虚拟机栈​ Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链栈、方法出口等信息。Java虚拟机栈也是线程私有，生命周期和线程相同。 ​ Java虚拟机栈中的局部变量表：存放编译期可知的各种基本数据类型、引用类型（reference）和runAddress类型。局部变量表所需要的内存空间在编译期间完成内存分配，在方法运行期间不会改变局部变量表的大小。 ​ 异常： 1）StackOverflowError：线程请求的栈的深度大于虚拟机所允许的深度。 2）OutOfMemoryError：扩展时无法申请到足够的内存。 三、本地方法栈​ 与Java虚拟机栈类似，线程私有，会抛出StackOverflowError和OutOfMemoryError异常。 ​ Java虚拟机栈区别是本地方法栈为虚拟机使用的Native方法服务，Java虚拟机栈为虚拟机执行Java方法服务。 四、Java堆​ 存放对象实例，被所有线程共享，虚拟机启动时创建。Java堆又称GC堆，垃圾收集器管理的主要区域。 ​ Java堆可以细分为：新生代和老年代。也可以分为Eden空间、From Survivor空间、To Survivor空间等。 如果在堆中没有内存完成实例分配，并且也无法再扩展，会抛出OutOfMemoryError异常 五、方法区​ 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是线程共享的区域。 ​ 与java堆一样不需要连续的内存和可以选择的固定大小并且可以扩展。不同点是可以选择不实现垃圾收集，这个区域主要的内存回收目标是针对常量池的回收和对类型的卸载。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 六、运行时常量池​ 是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。具备动态特性，运行时也能将新的常量存放入池。同样在无法申请内存时会抛出OutOfMemoryError异常。 七、直接内存​ 不是虚拟机运行数据区的一部分。NIO类可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。也会抛OutOfMemoryErrory异常","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://github.com/lgsdaredevil/categories/技术文章/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://github.com/lgsdaredevil/tags/jvm/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://github.com/lgsdaredevil/tags/虚拟机/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://github.com/lgsdaredevil/tags/读书笔记/"}]},{"title":"spring boot使用@Async异步任务","slug":"spring-boot使用@Async异步任务","date":"2018-07-17T03:04:05.000Z","updated":"2018-07-28T02:43:57.424Z","comments":true,"path":"2018/07/17/spring-boot使用@Async异步任务/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/17/spring-boot使用@Async异步任务/","excerpt":"","text":"github项目地址：https://github.com/lgsdaredevil/asyncTest 开启异步任务在应用主类中添加@EnableAsync注解 写异步任务方法12345678910111213@Async public Future&lt;String&gt; ansync(String name)&#123; try &#123; Thread.sleep(10000); logger.info(\"这里是异步方法\"); logger.info(\"传过来的名字是：\" + name); name = \"修改的名字\"; logger.info(\"修改后的名字是：\" + name); return new AsyncResult&lt;&gt;(\"name: \" + name); &#125;catch (Exception e)&#123; return new AsyncResult&lt;&gt;(\"异常\"); &#125; &#125; 调用异步方法 1、用Future获取返回值12345678910111213141516public String requestAnsync(String name)&#123; try &#123; Long start = System.currentTimeMillis(); Future&lt;String&gt; result = ansync(name); if (result.isDone())&#123; name = result.get(); logger.info(\"异步方法结束，名字改为：\" + name); &#125; Long end = System.currentTimeMillis(); logger.info(\"耗时：\" + (int)(end-start)); return \"hello \" + name; &#125;catch (Exception e)&#123; logger.error(\"异常\"); return \"异常\"; &#125; &#125; 返回值，若想获取到返回值，应该轮询方法获取，否则若果没有isDone则不会走下面的方法，或者可以使用CompletableFuture：12342018-07-17 11:31:55.390 INFO 5232 --- [nio-8080-exec-6] c.e.async.service.AsyncTestService : 耗时：02018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 这里是异步方法2018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 传过来的名字是：ling2018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 修改后的名字是：修改的名字 如果使用future.get()方法会阻塞线程直到拿到结果。 2、不使用future.get()方法，异步方法不使用Future返回1234567891011@Asyncpublic void noReturnAsync(String name)&#123; try &#123; Thread.sleep(10000); logger.info(\"这里是异步方法\"); logger.info(\"传过来的名字是：\" + name); name = \"修改的名字\"; logger.info(\"修改后的名字是：\" + name); &#125;catch (Exception e)&#123; &#125;&#125; 调用异步的方法1234567public String noReturn(String name)&#123; Long start = System.currentTimeMillis(); asyncTest.noReturnAsync(name); Long end = System.currentTimeMillis(); logger.info(\"耗时：\" + (int)(end-start)); return \"hello \" + name; &#125; 注意的地方：如果异步方法变成阻塞的同步方法，可能原因是异步方法和普通的调用方法在同一个类中，解决方法是将异步方法单独放到一个类中。产生原因：spring对@Transactional注解时也有类似问题，spring扫描时具有@Transactional注解方法的类时，是生成一个代理类，由代理类去开启关闭事务，而在同一个类中，方法调用是在类体内执行的，spring无法截获这个方法调用。具体参见：Spring Boot使用@Async实现异步调用","categories":[{"name":"技术文章项目","slug":"技术文章项目","permalink":"http://github.com/lgsdaredevil/categories/技术文章项目/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://github.com/lgsdaredevil/tags/spring-boot/"},{"name":"Async","slug":"Async","permalink":"http://github.com/lgsdaredevil/tags/Async/"},{"name":"异步","slug":"异步","permalink":"http://github.com/lgsdaredevil/tags/异步/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-13T11:52:49.718Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"2018/07/13/hello-world/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"部署hexo博客到github","slug":"部署hexo博客到github","date":"2018-07-11T07:55:19.000Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"2018/07/11/部署hexo博客到github/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/11/部署hexo博客到github/","excerpt":"","text":"部署hexo博客到github准备工具&nbsp;&nbsp;&nbsp;&nbsp;Node.js&nbsp;&nbsp;&nbsp;&nbsp;Git&nbsp;&nbsp;&nbsp;&nbsp;GitHub Hexo安装在新目录下输入命令：npm install -g hexo-cli 创建博客文件夹博客目录下输入命令：hexo init 安装依赖包npm install 修改配置文件修改_config.yml文件 url: http://github.com/ root: /newblog permalink: :year/:month/:day/:title/ permalink_defaults:root为文件目录的跟目录 deploy: # 部署相关配置 type: git # 使用 Git 提交 repository: https://github.com/xxx/xxx.github.io.git # 博客仓库地址 repository后地址为github的项目地址 生成文件hexo g 或者 hexo generate 启动服务hexo s 或 hexo server浏览器输入 http://localhost:4000/(root的目录)查看 发布hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 注意如果发布时候报错： ERROR Deployer not found: Git输入命令：npm install hexo-deployer-git –save，重新发布即可","categories":[{"name":"个人博客","slug":"个人博客","permalink":"http://github.com/lgsdaredevil/categories/个人博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://github.com/lgsdaredevil/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://github.com/lgsdaredevil/tags/github/"},{"name":"部署博客","slug":"部署博客","permalink":"http://github.com/lgsdaredevil/tags/部署博客/"}]}]}