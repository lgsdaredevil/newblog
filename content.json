{"meta":{"title":"小森的博客","subtitle":null,"description":null,"author":null,"url":"http://github.com/lgsdaredevil"},"pages":[{"title":"about","date":"2018-07-11T03:27:42.000Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"about/index.html","permalink":"http://github.com/lgsdaredevil/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-11T03:26:14.000Z","updated":"2018-07-13T11:52:49.733Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/lgsdaredevil/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-07-11T03:26:05.000Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"categories/index.html","permalink":"http://github.com/lgsdaredevil/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"java虚拟机笔记（一）","slug":"java虚拟机笔记（一）","date":"2018-07-28T00:43:53.000Z","updated":"2018-07-28T02:44:11.535Z","comments":true,"path":"2018/07/28/java虚拟机笔记（一）/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/28/java虚拟机笔记（一）/","excerpt":"","text":"JDK和JRE区别​ 1、一般把Java程序设计语言，java虚拟机，java API类库这三部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境。 ​ 2、Java API类库中Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境。 Java虚拟机内存区域一、程序计数器​ 可以看做当前线程所执行的字节码的行号指示器。为线程私有的内存。是在Java虚拟机内存区域唯一一个不会内存溢出的区域。 二、Java虚拟机栈​ Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链栈、方法出口等信息。Java虚拟机栈也是线程私有，生命周期和线程相同。 ​ Java虚拟机栈中的局部变量表：存放编译期可知的各种基本数据类型、引用类型（reference）和runAddress类型。局部变量表所需要的内存空间在编译期间完成内存分配，在方法运行期间不会改变局部变量表的大小。 ​ 异常： 1）StackOverflowError：线程请求的栈的深度大于虚拟机所允许的深度。 2）OutOfMemoryError：扩展时无法申请到足够的内存。 三、本地方法栈​ 与Java虚拟机栈类似，线程私有，会抛出StackOverflowError和OutOfMemoryError异常。 ​ Java虚拟机栈区别是本地方法栈为虚拟机使用的Native方法服务，Java虚拟机栈为虚拟机执行Java方法服务。 四、Java堆​ 存放对象实例，被所有线程共享，虚拟机启动时创建。Java堆又称GC堆，垃圾收集器管理的主要区域。 ​ Java堆可以细分为：新生代和老年代。也可以分为Eden空间、From Survivor空间、To Survivor空间等。 如果在堆中没有内存完成实例分配，并且也无法再扩展，会抛出OutOfMemoryError异常 五、方法区​ 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是线程共享的区域。 ​ 与java堆一样不需要连续的内存和可以选择的固定大小并且可以扩展。不同点是可以选择不实现垃圾收集，这个区域主要的内存回收目标是针对常量池的回收和对类型的卸载。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 六、运行时常量池​ 是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。具备动态特性，运行时也能将新的常量存放入池。同样在无法申请内存时会抛出OutOfMemoryError异常。 七、直接内存​ 不是虚拟机运行数据区的一部分。NIO类可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。也会抛OutOfMemoryErrory异常","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://github.com/lgsdaredevil/categories/技术文章/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://github.com/lgsdaredevil/tags/jvm/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://github.com/lgsdaredevil/tags/虚拟机/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://github.com/lgsdaredevil/tags/读书笔记/"}]},{"title":"spring boot使用@Async异步任务","slug":"spring-boot使用@Async异步任务","date":"2018-07-17T03:04:05.000Z","updated":"2018-07-28T02:43:57.424Z","comments":true,"path":"2018/07/17/spring-boot使用@Async异步任务/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/17/spring-boot使用@Async异步任务/","excerpt":"","text":"github项目地址：https://github.com/lgsdaredevil/asyncTest 开启异步任务在应用主类中添加@EnableAsync注解 写异步任务方法12345678910111213@Async public Future&lt;String&gt; ansync(String name)&#123; try &#123; Thread.sleep(10000); logger.info(\"这里是异步方法\"); logger.info(\"传过来的名字是：\" + name); name = \"修改的名字\"; logger.info(\"修改后的名字是：\" + name); return new AsyncResult&lt;&gt;(\"name: \" + name); &#125;catch (Exception e)&#123; return new AsyncResult&lt;&gt;(\"异常\"); &#125; &#125; 调用异步方法 1、用Future获取返回值12345678910111213141516public String requestAnsync(String name)&#123; try &#123; Long start = System.currentTimeMillis(); Future&lt;String&gt; result = ansync(name); if (result.isDone())&#123; name = result.get(); logger.info(\"异步方法结束，名字改为：\" + name); &#125; Long end = System.currentTimeMillis(); logger.info(\"耗时：\" + (int)(end-start)); return \"hello \" + name; &#125;catch (Exception e)&#123; logger.error(\"异常\"); return \"异常\"; &#125; &#125; 返回值，若想获取到返回值，应该轮询方法获取，否则若果没有isDone则不会走下面的方法，或者可以使用CompletableFuture：12342018-07-17 11:31:55.390 INFO 5232 --- [nio-8080-exec-6] c.e.async.service.AsyncTestService : 耗时：02018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 这里是异步方法2018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 传过来的名字是：ling2018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 修改后的名字是：修改的名字 如果使用future.get()方法会阻塞线程直到拿到结果。 2、不使用future.get()方法，异步方法不使用Future返回1234567891011@Asyncpublic void noReturnAsync(String name)&#123; try &#123; Thread.sleep(10000); logger.info(\"这里是异步方法\"); logger.info(\"传过来的名字是：\" + name); name = \"修改的名字\"; logger.info(\"修改后的名字是：\" + name); &#125;catch (Exception e)&#123; &#125;&#125; 调用异步的方法1234567public String noReturn(String name)&#123; Long start = System.currentTimeMillis(); asyncTest.noReturnAsync(name); Long end = System.currentTimeMillis(); logger.info(\"耗时：\" + (int)(end-start)); return \"hello \" + name; &#125; 注意的地方：如果异步方法变成阻塞的同步方法，可能原因是异步方法和普通的调用方法在同一个类中，解决方法是将异步方法单独放到一个类中。产生原因：spring对@Transactional注解时也有类似问题，spring扫描时具有@Transactional注解方法的类时，是生成一个代理类，由代理类去开启关闭事务，而在同一个类中，方法调用是在类体内执行的，spring无法截获这个方法调用。具体参见：Spring Boot使用@Async实现异步调用","categories":[{"name":"技术文章项目","slug":"技术文章项目","permalink":"http://github.com/lgsdaredevil/categories/技术文章项目/"}],"tags":[{"name":"java","slug":"java","permalink":"http://github.com/lgsdaredevil/tags/java/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://github.com/lgsdaredevil/tags/spring-boot/"},{"name":"Async","slug":"Async","permalink":"http://github.com/lgsdaredevil/tags/Async/"},{"name":"异步","slug":"异步","permalink":"http://github.com/lgsdaredevil/tags/异步/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-13T11:52:49.718Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"2018/07/13/hello-world/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"部署hexo博客到github","slug":"部署hexo博客到github","date":"2018-07-11T07:55:19.000Z","updated":"2018-07-13T11:52:49.718Z","comments":true,"path":"2018/07/11/部署hexo博客到github/","link":"","permalink":"http://github.com/lgsdaredevil/2018/07/11/部署hexo博客到github/","excerpt":"","text":"部署hexo博客到github准备工具&nbsp;&nbsp;&nbsp;&nbsp;Node.js&nbsp;&nbsp;&nbsp;&nbsp;Git&nbsp;&nbsp;&nbsp;&nbsp;GitHub Hexo安装在新目录下输入命令：npm install -g hexo-cli 创建博客文件夹博客目录下输入命令：hexo init 安装依赖包npm install 修改配置文件修改_config.yml文件 url: http://github.com/ root: /newblog permalink: :year/:month/:day/:title/ permalink_defaults:root为文件目录的跟目录 deploy: # 部署相关配置 type: git # 使用 Git 提交 repository: https://github.com/xxx/xxx.github.io.git # 博客仓库地址 repository后地址为github的项目地址 生成文件hexo g 或者 hexo generate 启动服务hexo s 或 hexo server浏览器输入 http://localhost:4000/(root的目录)查看 发布hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 注意如果发布时候报错： ERROR Deployer not found: Git输入命令：npm install hexo-deployer-git –save，重新发布即可","categories":[{"name":"个人博客","slug":"个人博客","permalink":"http://github.com/lgsdaredevil/categories/个人博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://github.com/lgsdaredevil/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://github.com/lgsdaredevil/tags/github/"},{"name":"部署博客","slug":"部署博客","permalink":"http://github.com/lgsdaredevil/tags/部署博客/"}]}]}